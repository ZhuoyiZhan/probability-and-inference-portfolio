---
title: "writeup"
output: html_document
---
# 01-roulette
### Zhuoyi Zhan
### September 06, 2021



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

knitr::opts_chunk$set(dev = 'svg') # set output device to svg
```

## Introduction

In this question I want to answer the question to decide if Martingale strategy is always profitable. The purpose is to use programming to simulate real-life roulette, calculate average earning of the Martingale betting strategy and see if different input parameters would impact the average earnings. 

## 1.1 Backgound

Roulette is a popular gambling game. Starting at $1, if player guess right, he/she will get her money back and win double the bet. The Martingale is a common betting strategy that seems to guarantee return. When player lose souble the size of bet until winnig. We try to estimate the earning yielded by setting starting budget, winning threshold, maximum wager, and maximum game. The key to the average earning is repeating the simulations and taking means.

## 2 Methods

In this simulation, functions help to accomplish tasks like spinning wheels, recording outcomes and calculating budget.

```{r}
library(dplyr)
library(tidyverse)
#' A single play of the Martingale strategy
#'
#' Takes a state list, spins the roulette wheel, returns the state list with updated values (for example, budget, plays, etc)
#' @param state A list with the following entries: 
#'   B              number, the budget
#'   W              number, the budget threshold for successfully stoping
#'   L              number, the maximum number of plays 
#'   M              number, the casino wager limit
#'   plays          integer, the number of plays executed
#'   previous_wager number, the wager in the previous play (0 at first play)
#'   previous_win   TRUE/FALSE, indicator if the previous play was a win (TRUE at first play)
#' @return The updated state list
one_play <- function(state){
  
    # Wager
    proposed_wager <- ifelse(state$previous_win, 1, 2*state$previous_wager)
    wager <- min(proposed_wager, state$M, state$B)
    
    # Spin of the wheel
    red <- rbinom(1,1,18/38)
    
    # Update state
    state$plays <- state$plays + 1
    state$previous_wager <- wager
    if(red){
      # WIN
      state$B <- state$B + wager
      state$previous_win <- TRUE
    }else{
      # LOSE
      state$B <- state$B - wager
      state$previous_win <- FALSE
    }
  state
}


#' Stopping rule
#'
#' Takes the state list and determines if the gambler has to stop
#' @param state A list.  See one_play
#' @return TRUE/FALSE
stop_play <- function(state){
  if(state$B <= 0) return(TRUE) #plyers lose all money
  if(state$plays >= state$L) return(TRUE) #player reaches max games
  if(state$B >= state$W) return(TRUE) #player get to the budget threshold
  FALSE
}


#' Play roulette to either bankruptcy, success, or play limits
#'
#' @param B number, the starting budget
#' @param W number, the budget threshold for successfully stoping
#' @param L number, the maximum number of plays 
#' @param M number, the casino wager limit
#' @return A vector of budget values calculated after each play.
one_series <- function(
    B = 200
  , W = 300
  , L = 1000
  , M = 100
){

  # initial state
  state <- list(
    B = B
  , W = W
  , L = L
  , M = M
  , plays = 0
  , previous_wager = 0
  , previous_win = TRUE
  )
  
  # vector to store budget over series of plays
  budget <- rep(NA, L)
  
  # For loop of plays
  for(i in 1:L){
    new_state <- state %>% one_play
    budget[i] <- new_state$B
    if(new_state %>% stop_play){
      return(budget[1:i])
    }
    state <- new_state
  }
  budget    
}

# helper function
get_last <- function(x) x[length(x)] 
```
Possible Outcomes:
### 1
![Figure of wining](winner.svg){#id .class width=50% height=50%}

### 2
![Figure of losing](loser.svg){#id .class width=50% height=50%}




Simulation for 1000 times:
```{r}
# Simulation
walk_out_money <- rep(NA, 10000)
for(j in seq_along(walk_out_money)){
  walk_out_money[j] <- one_series(B = 200, W = 300, L = 1000, M = 100) %>% get_last
}

# Walk out money distribution
hist(walk_out_money, breaks = 100)
```

```{r}
# Estimated probability of walking out with extra cash
mean(walk_out_money > 200)

# Estimated earnings
mean(walk_out_money - 200)
```




```{r}
#This step we are trying to  simulate spinning the roulette. sample() is a function can take a random sample from the data object. In this case, yield a result from 18 red, 18 black, and 2 green
single_spin <- function(){
  possible_outcomes <- c(rep("red",18), rep("black",18), rep("green",2))
  sample(possible_outcomes, 1)
}

#This step is trying to simulate the betting strategy. It receives input of previous wager, last spinning result, maximum wager that casino set and how much much palyer left with. If last spin player get red, then keep bet $1 on red, else, 2 times the previous wager but it should not exceed player's current budget or maximum wager allowed.

martingale_wager <- function(
  previous_wager
  , previous_outcome
  , max_wager
  , current_budget
){
  if(previous_outcome == "red") return(1)
  min(2*previous_wager, max_wager, current_budget)
}

one_play <- function(previous_ledger_entry, max_wager){
  # Create a copy of the input object that will become the output object
  out <- previous_ledger_entry
  out[1, "game_index"] <- previous_ledger_entry[1, "game_index"] + 1
  #game index is increasing with the number of game played. 
  out[1, "starting_budget"] <- previous_ledger_entry[1, "ending_budget"]
  #Each game, player have budget of what they left from last game.
  out[1, "wager"] <- martingale_wager(
    previous_wager = previous_ledger_entry[1, "wager"]
    , previous_outcome = previous_ledger_entry[1, "outcome"]
    , max_wager = max_wager
    , current_budget = out[1, "starting_budget"]
  )
  #To get and record this time's wager in, it call martingale_wager() function with last time's wager, outcomes,max wager and this time's starting budget.
  out[1, "outcome"] <- single_spin()
  # Calling the single_spin() function to get an outcome and record.
  out[1, "ending_budget"] <- out[1, "starting_budget"] + 
    ifelse(out[1, "outcome"] == "red", +1, -1)*out[1, "wager"]
  return(out)
  #the new ending budget will be starting budget plus wager if outcome is red, or minus wager is not red.
}

one_series <- function(
  max_games, starting_budget, winning_threshold, max_wager
){
  # Initialize ledger
  ledger <- data.frame(
      game_index = 0:max_games
    , starting_budget = NA_integer_
    , wager = NA_integer_
    , outcome = NA_character_
    , ending_budget = NA_integer_
  )#this defines the variable types.
  ledger[1, "wager"] <- 1
  ledger[1, "outcome"] <- "red"
  ledger[1, "ending_budget"] <- starting_budget
  # the wager starts with 1.
  for(i in 2:nrow(ledger)){
    #browser()
    ledger[i,] <- one_play(ledger[i-1,], max_wager)
    # i is this time, i-1 refer to the last game. By calling one_play() with last game, this step keeps recording every game played.
    if(stopping_rule(ledger[i,], winning_threshold)) break
  } #this will check if the plyyer reaches stopping rules. If yes then stop.
  # Return non-empty portion of ledger
  ledger[2:i, ]
}

stopping_rule <- function(
  ledger_entry
  , winning_threshold
){
  ending_budget <- ledger_entry[1, "ending_budget"]
  if(ending_budget <= 0) return(TRUE)
  if(ending_budget >= winning_threshold) return(TRUE)
  FALSE
}# The rule to stop are when running out of money or now having money that is equal or more than winning threshold. 

profit <- function(ledger){
  n <- nrow(ledger)
  profit <- ledger[n, "ending_budget"] - ledger[1, "starting_budget"]
  return(profit)
} # The profit equals to last game's budget minus budget at first.

require(magrittr)

# It creates figures of winning and losing with starting budget of $200, winning threshold of $300, maximum 1000 plays and maximum wager of $100
svg(filename = "loser.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,300,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "winner.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,300,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()
```

## 3 Results

```{r}
nlength <- 10
output_list <- vector(mode = "list", length = nlength)
for (i in seq(1, 10, by=1)){
  set.seed(i)
  l <- one_series(1000,200,300,100)
  output_list[i] <- profit(l)
}

print(output_list)
```
```{r}
svg(filename = "WT_loser_300.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,300,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_loser_250.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,250,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_loser_400.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,400,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_winne_250.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,250,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")

svg(filename = "WT_winne_300.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,300,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")

dev.off()
svg(filename = "WT_winne_400.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,400,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()
```

From the svg figures, we can see by changing winning threshold. A lower threshold results in faster win and higher threshold results in slower win. But for losing, threshold does not matter.

## 4 Conclusions
By changing the input parameter and repeatedly simulate, we find that Martingale betting strategy does not guarantee earnings. A player can reach winning threshold or lose all money. The average earning is (still working on the loop). So this strategy is not always profitable.  A lower threshold results in faster win and higher threshold results in slower win. 