---
title: "writeup"
output: html_document
---
# 01-roulette
### Zhuoyi Zhan
### September 06, 2021



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
In this question I want to answer the question to decide if Martingale strategy is always profitable. The purpose is to use programming to simulate real-life roulette, calculate average earning of the Martingale betting strategy and see if different input parameters would impact the average earnings. 
## 1.1 Backgound
Roulette is a popular gambling game. If player guess right, he/she will get her money back and win wager amount. The Martingale is a common betting strategy that seems to guarantee return. We try to estimate the earning yield from this strategy by setting starting budget, winning threshold, maximum wager, and maximum game to  play like in real life. 
In this simulation, functions help to accomplish tasks like spinning wheels, recording outcomes and calculating budget. We also want to see what results input parameters lead to, i.e. by changing starting budget, maximum wager, maximum game  The key property is the average earning whichderived from repeating the simulation several times and taking means.
## 2 Methods
In this 

```{r}

#This step we are trying to  simulate spinning the roulette. sample() is a function can take a random sample from the data object. In this case, yield a result from 18 red, 18 black, and 2 green
single_spin <- function(){
  possible_outcomes <- c(rep("red",18), rep("black",18), rep("green",2))
  sample(possible_outcomes, 1)
}

#This step is trying to simulate the betting strategy. It receives input of previous wager, last spinning result, maximum wager that casino set and how much much palyer left with. If last spin player get red, then keep bet $1 on red, else, 2 times the previous wager but it should not exceed player's current budget or maximum wager allowed.

martingale_wager <- function(
  previous_wager
  , previous_outcome
  , max_wager
  , current_budget
){
  if(previous_outcome == "red") return(1)
  min(2*previous_wager, max_wager, current_budget)
}

one_play <- function(previous_ledger_entry, max_wager){
  # Create a copy of the input object that will become the output object
  out <- previous_ledger_entry
  out[1, "game_index"] <- previous_ledger_entry[1, "game_index"] + 1
  #game index is increasing with the number of game played. 
  out[1, "starting_budget"] <- previous_ledger_entry[1, "ending_budget"]
  #Each game, player have budget of what they left from last game.
  out[1, "wager"] <- martingale_wager(
    previous_wager = previous_ledger_entry[1, "wager"]
    , previous_outcome = previous_ledger_entry[1, "outcome"]
    , max_wager = max_wager
    , current_budget = out[1, "starting_budget"]
  )
  #To get and record this time's wager in, it call martingale_wager() function with last time's wager, outcomes,max wager and this time's starting budget.
  out[1, "outcome"] <- single_spin()
  # Calling the single_spin() function to get an outcome and record.
  out[1, "ending_budget"] <- out[1, "starting_budget"] + 
    ifelse(out[1, "outcome"] == "red", +1, -1)*out[1, "wager"]
  return(out)
  #the new ending budget will be starting budget plus wager if outcome is red, or minus wager is not red.
}

one_series <- function(
  max_games, starting_budget, winning_threshold, max_wager
){
  # Initialize ledger
  ledger <- data.frame(
      game_index = 0:max_games
    , starting_budget = NA_integer_
    , wager = NA_integer_
    , outcome = NA_character_
    , ending_budget = NA_integer_
  )#this defines the variable types.
  ledger[1, "wager"] <- 1
  ledger[1, "outcome"] <- "red"
  ledger[1, "ending_budget"] <- starting_budget
  # the wager starts with 1.
  for(i in 2:nrow(ledger)){
    #browser()
    ledger[i,] <- one_play(ledger[i-1,], max_wager)
    # i is this time, i-1 refer to the last game. By calling one_play() with last game, this step keeps recording every game played.
    if(stopping_rule(ledger[i,], winning_threshold)) break
  } #this will check if the plyyer reaches stopping rules. If yes then stop.
  # Return non-empty portion of ledger
  ledger[2:i, ]
}

stopping_rule <- function(
  ledger_entry
  , winning_threshold
){
  ending_budget <- ledger_entry[1, "ending_budget"]
  if(ending_budget <= 0) return(TRUE)
  if(ending_budget >= winning_threshold) return(TRUE)
  FALSE
}# The rule to stop are when running out of money or now having money that is equal or more than winning threshold. 

profit <- function(ledger){
  n <- nrow(ledger)
  profit <- ledger[n, "ending_budget"] - ledger[1, "starting_budget"]
  return(profit)
} # The profit equals to last game's budget minus budget at first.

require(magrittr)

# It creates figures of winning and losing with starting budget of $200, winning threshold of $300, maximum 1000 plays and maximum wager of $100
svg(filename = "loser.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,300,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "winner.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,300,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()
```
## 3 Results
```{r}
nlength <- 10
output_list <- vector(mode = "list", length = nlength)
for (i in seq(1, 10, by=1)){
  set.seed(i)
  l <- one_series(1000,200,300,100)
  output_list[i] <- profit(l)
}

print(output_list)
```
```{r}
svg(filename = "WT_loser_300.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,300,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_loser_250.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,250,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_loser_400.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(1)
ledger <- one_series(1000,200,400,100)
plot(ledger[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()

svg(filename = "WT_winne_250.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,250,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")

svg(filename = "WT_winne_300.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,300,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")

dev.off()
svg(filename = "WT_winne_400.svg", width=16, height =9)
par(cex.axis=2, cex.lab = 2, mar = c(8,8,2,2), bg = rgb(222, 235, 247, max = 255))
set.seed(2)
l2 <- one_series(1000,200,400,100)
plot(l2[,c(1,5)], type = "l", lwd = 5, xlab = "Game Index", ylab = "Budget")
dev.off()
```

From the svg figures, we can see by changing winning threshold. A lower threshold results in faster win and higher threshold results in slower win. But for losing, threshold does not matter.

## 4 Conclusions
By changing the input parameter and repeatedly simulate, we find that Martingale betting strategy does not guarantee earnings. A player can reach winning threshold or lose all money. The average earning is (still working on the loop). So this strategy is not always profitable.  A lower threshold results in faster win and higher threshold results in slower win. 